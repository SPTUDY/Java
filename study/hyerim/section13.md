## 좋은 객체 지향 프로그래밍

### 객체 지향 특징

- 추상화
- 캡슐화
- 상속
- **다형성**

---

### 객체지향 프로그래밍

- 컴퓨터 프로그램을 객체들의 모임으로 파악
- 프로그램을 유연하고 변경에 용이하게 만듦

---

## 다형성

### 실세계 비유

**역할과 구현으로 세상을 구분**

**예시 1**
- 운전자 역할, 자동차 역할이 있음
- 자동차 구현: K3, 아반떼, 테슬라 모델3 …
- 운전자 역할 입장에서 자동차 구현이 바뀌어도 운전 가능
- 자동차 역할이라는 인터페이스를 따라 자동차 구현이 되어 있기 때문

**예시 2**
- 로미오와 줄리엣 공연
- 로미오 역할, 줄리엣 역할이 있음
- 여러 배우는 각각 로미오 역할, 줄리엣 역할을 할 수 있음
- 배우는 대체 가능 → 유연하고 변경 용이
- 줄리엣 역할 배우가 바뀌더라도 로미오 역할 배우에게 영향 없음

---

### 역할과 구현을 분리

- 클라이언트는 인터페이스만 알면 됨
- 내부 구조를 몰라도 되며, 내부 구조 변경 시에도 영향 없음
- 클라이언트는 구현 대상이 바뀌더라도 영향 받지 않음
    - 예: 차종이 바뀌어도 운전자 역할에서는 영향 없음
    - 예: 줄리엣 배우가 바뀌어도 로미오 역할 배우는 영향 없음

- **역할** = 인터페이스
- **구현** = 인터페이스를 구현한 클래스, 객체

→ 객체를 설계할 때 역할과 구현을 명확히 분리  
→ 역할(인터페이스) 먼저 부여하고, 역할을 수행하는 구현 객체 만들기

---

### 다형성의 본질

- 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경 가능
- 클라이언트 변경 없이 서버의 구현 기능을 유연하게 변경
- 확장 가능한 설계 가능 (메서드 오버라이딩을 통해)

**한계**
- 인터페이스 자체가 변하면 클라이언트와 서버 모두 큰 변경 발생
- → 인터페이스를 안정적으로 설계하는 것이 중요

---

## 다형성: 역할과 구현 / 예제

### 예제: `Driver`, `K3Car`, `Model3Car`

- `Driver`는 `K3Car` 인스턴스 변수를 가짐 → 운전자가 K3 자동차를 알고 있음
- `setK3Car()` 메서드를 호출하면서 인스턴스 주입
- 외부에서 참조값이 넘어와서 K3 자동차 운전 가능

**다형성 없이 새로운 차량(Model3Car) 추가하면**
- `Driver` 코드에 많은 변경 필요
- 자동차가 늘어날수록 운전자 코드, Main 코드 모두 수정 필요
- null 여부 분기처리 등 복잡해짐 → 역할과 구현을 분리하지 않아서 생긴 문제

---

### 다형성 활용

- `Driver`: **클라이언트**
    - 역할인 `Car`에만 의존 (구현에는 의존하지 않음)
    - `Driver` 클래스는 `Car car` 멤버 변수 가짐
    - `Car`에만 의존 → `K3Car`, `Model3Car`는 모름

> **의존**: 클래스 의존 관계, 클래스 상에서 어떤 클래스를 알고 있는지를 의미

- `Car`: **역할**
- `K3Car`, `Model3Car`: **Car의 구현**

**동작 흐름**
- `Driver`는 `Car`만을 가짐 (인터페이스)
- `K3Car`를 생성하고 `driver.setCar()` 호출 → `Car` 필드가 `K3Car` 인스턴스 참조
- `driver.drive()` 호출 시 `K3Car` 기능 실행됨 (**오버라이딩**)

---

## OCP (Open-Closed Principle) 원칙

좋은 객체 지향 설계 원칙

- **Open for Extension**: 새로운 기능 추가/변경 시 기존 코드 확장 가능
- **Closed for Modification**: 기존 코드는 수정되지 않아야 함

---

### 예제 - 새로운 차량 추가

- 새로운 차량(NewCar) 추가해도 **Driver 코드 수정 없음**
- Main을 제외한 기존 코드는 전혀 수정하지 않음

**확장에 열려있다는 의미**
- `Car` 인터페이스를 통해 새 차량 자유롭게 추가 가능
- `Driver`도 인터페이스로 새 차량 자유롭게 호출 가능

**코드 수정은 닫혀있다는 의미**
- 새 차를 추가하면 기능은 추가되나, 기존 코드 수정은 최소화
- 변경이 필요한 부분은 `Main`처럼 외부에서 객체를 전달해주는 영역

---

### OCP 요약

- **변하지 않는 부분**: 클라이언트 (`Driver`) 코드
- **변하는 부분**: Main에서 객체 생성 및 주입하는 부분

---

## 전략 패턴

- 알고리즘을 클라이언트 코드 변경 없이 쉽게 교체할 수 있어야 함

**전략 구조**
- `Car` 인터페이스 → 전략을 정의하는 인터페이스
- `K3Car`, `Model3Car` 등 → 전략의 구체적인 구현
- 클라이언트 `Driver`는 인터페이스만 알고 있으며, 전략을 교체해도 코드 변경 없음