## 상속

### 예제

자동차  
⌊전기차  
⌊⌊이동  
⌊⌊주유  
⌊가솔린차  
⌊⌊이동  
⌊⌊주유  
  
- 전기차와 가솔린차는 자동차라는 상위 개념에 포함
- 즉, 전기차와 가솔린차는 자동차의 구체적인 개념
- 전기차와 가솔린차는 이동이라는 **공통적인 기능**이 있음
- `상속` 관계를 사용하는 것이 효과적
  - 자동차는 부모, 전기차와 가솔린차는 자식

### 상속 관계

기존 클래스의 필드와 메서드를 새로운 클래스에서 그대로 재사용   
`extends` 키워드 사용  
`extends` 대상은 하나만 선택 가능  
  
- **부모 클래스 (슈퍼 클래스)**: 상속을 통해 자신의 필드와 메서드를 다른 클래스에 제공
- **자식 클래스 (서브 클래스)**: 부모 클래스로부터 필드와 메서드를 상속
  
ElectricCar와 GasCar은 Car을 상속 받음
- `extends Car`을 통해 자식 클래스에서 부모 클래스에 있는 move() 메서드 사용 가능
- 부모는 자식에 대해서 알지 모름
  - 어느 클래스에서 자신을 상속받는지 모름
  - 부모는 자식에게 접근할 수 없음
  - 예를 들어 Car에서 ElectricCar의 charge()에 접근 불가능

### 단일 상속

extends의 대상을 하나만 선택할 수 있음  
하나의 자식이 여러 부모를 갖는 것은 불가능  
  
**다중 상속의 문제점**
예를 들어, AirplaneCar이라는 자식 클래스에서 Airplane클래스와 Car클래스를 동시에 상속 받고,  
두 클래스 모두 move()라는 메서드를 갖고 있다면, 자식 클래스에서 move()를 호출했을 때 어느 메서드를 사용할 지 모름  
- 다이아몬드 문제, 클래스 계층 구조도가 복잡해짐
- **인터페이스**에서는 다중 구현을 허용

## 상속과 메모리 구조

### 예시

ElectricCar에서 Car을 상속 받고 있을 때,  
ElectricCar을 호출하면 Car까지 함께 포함하여 인스턴스 생성  
참조값은 x001로 하나이지만, 그 안에는 Car, ElectricCar **두개의 클래스 공존**  
- 필드와 메서드만 물려받는 것이 아니라, 부모 클래스의 인스턴스도 생성
- 부모 클래스 인스턴스도 메모리를 차지하고 있음

특정 메서드를 호출하면 **어떤 클래스의 메서드를 호출할지 선택**해야 함
- 호출하는 인스턴스틔 타입(어떤 클래스로부터 생성되었는지)을 기준으로 선택
- 예를 들어 electricCar이면 해당 인스턴스의 메서드를 호출

만약 부모 클래스의 메서드를 호출하는 경우
- electricCar 인스턴스에서 호출했지만 해당 메서드가 없기 때문에 부모 클래스에서 메서드를 찾음
- 부모 클래스의 메서드가 호출됨
- 만약 부모 클래스에 해당 메서드가 없고, 그 상위 클래스에도 없다면 **컴파일 오류**

### 기능 추가

많은 자식 클래스에서 공통으로 사용하는 기능이 있다면,  
부모 클래스에 한번 추가함으로써 해당 기능을 자식 클래스들이 모두 이용 가능  
- 예를 들어, Car을 상속 받는 ElectricCar, GasCar 모두 Car에 기능을 추가하면 해당 기능을 이용할 수 있음
- **상속**을 통해 **코드의 중복성을 낮출 수 있게 됨**
- 즉 상속의 장점은 **확장의 용이성**

## 메서드 오버라이딩

부모 타입의 기능을 자식에서 다르게 사용하고자 할 때,  
예를 들어 Car.move() 기능은 "차를 이동합니다." 문구를 출력
그러나 전기차의 경우, 가스차의 경우를 각각 다르게 출력하고자 할 때??  

부모에게서 상속받은 기능을 자식이 재정의하는 것을 **메서드 오버라이딩**이라고 함
기능을 다르게 하고 싶은 클래스에서 오버라이딩
```java
@Override
public void move() {
  System.out.println("전기차를 빠르게 이동합니다.");
}
```
위와 같이 오버라이딩을 통해 electronicCar.move()는 위와 같이 출력되고,  
다른 Car을 상속 받은 gasCar, hydrogenCar은 Car.move()의 메서드를 호출  

`@Override`: 프로그램이 읽을 수 있는 특별한 annotation / 주석
- 없어도 그대로 출력됨
- 그러나 annotation을 통해서 오버라이드가 제대로 되었다는 것을 알 수 있음
- 만약 annotation이 붙었는데 제대로 오버라이드가 되지 않았으면 **컴파일 오류** 발생
  - 실수로 오버라이드가 되지 않은 경우를 방지

**오버라이드 시 메모리 구조**
자식 클래스에서 오버라이드한 메서드를 이미 찾았기 때문에 부모 클래스까지 올라가서 해당 메서드를 찾을 필요 없음
- 오버로딩과 다른 것
- 오버로딩: 과적이라는 뜻, 메서드 이름과 같고 매개변수가 다른 메서드를 여러개 정의
- 오버라이딩: 기존 기능을 새로운 기능으로 재정의

**메서드 오버라이딩 조건**
- 메서드 이름이 동일, 파라미터 타입 / 순서 / 개수 동일
- 반환 타입 동일
- 상위 클래스보다 접근 제어자가 더 제한적이면 안됨
- 상위 클래스보다 더 많은 예외 throws 처리 가능
- static, final, private 키워드가 붙은 메서드는 오버라이딩 불가능
  - 만약 메서드가 final은 오버라이딩 불가능: final은 수정 불가능
  - private은 해당 클래스 내부에서만 접근 가능 ... 자식이 접근할 수 없음
  - static은 무의미함
- 생성자 오버라이딩 불가능

## 접근 제어

**접근 제어자** UML 표기법  
- `+`: public, 모든 외부 호출을 허용
- `#`: protected, 같은 패키지 안에서 호출 허용 및 **패키지가 달라도 상속 관계 호출 허용**  
- `~`: default, 같은 패키지 안에서 호출 허용
- `-`: private, 모든 외부 호출을 막음

**예제**: 다른 패키지의 자식 클래스에서 부모 클래스의 어디까지 접근 가능한가?  
- `public`, `protected` 접근 가능
- `default`, `private` 접근 불가능
- `default`, `private`에 접근하고자 하면 **컴파일 오류** 발생

**접근 제어와 메모리 구조**  
- 본인 타입에 없으면 부모 타입에서 찾음
- 왜냐하면 객체 내부는 자식과 부모가 구분되어 있음
- 자식 타입에서 부모 타입의 기능을 호출할 때, 부모 입장에서는 **외부에서 호출**한 것과 동일

## super 

### 부모 참조

메서드 오버라이딩이 되어있는 경우, 자식에게 있다면 부모에게서 찾지 않고 바로 끝냄  
즉, 부모의 메서드를 호출할 수 없음  
- 그러나 `super` 키워드를 사용하면 부모를 참조할 수 있음

```java
public class Child extends Parent {

    public String value = "child";

    @Override
    public void hello() {
        System.out.println("Child.hello");
    }

    public void call() {
        System.out.println("this value = " + this.value);
        System.out.println("super value = " + super.value);

        this.hello();
        super.hello();
    }
}
```
this는 자기 자신(Child)의 메서드 및 변수를 의미 → **this 생략 가능**  
super은 부모에서 찾음 → 부모 클래스의 기능을 사용할 수 있음  

**super 메모리 구조**
- super 키워드가 있으면 본인(자식)에서 먼저 찾지 않고 부모 클래스에서 먼저 찾음

### 생성자

상속 관계의 인스턴스... 자식 인스턴스를 생성하면 부모 인스턴스도 생성됨  
즉, 메모리 내부에서는 Child를 만들면 Parent도 만들어짐  
따라서 각각의 생성자도 만들어줘야 함  
**상속 관계를 사용하면 자식 클래스의 생성자에서 부모 클래스의 생성자를 반드시 호출**  
→ 지키지 않을 시 **컴파일 오류** 발생
- `super(...)` 키워드 사용

부모 생성자가 **매개변수가 없는 기본 생성자**인 경우에는 super() 생략 가능  
그러나, 매개변수가 있는 생성자를 따로 정의하면 자바에서는 기본 생성자를 만들지 않음  
따라서 부모 클래스에 생성자가 따로 정의되어 있는 경우, super() 직접 호출  

부모 클래스의 생성자가 기본 생성자인 경우에만 super() 생략 가능
만약 부모 클래스에 생성자가 매개변수가 있는 생성자로 정의되어 있다면 자식 클래스에서도 부모 생성자를 호출해주어야 함

(부모) ClassA > ClassB > ClassC (자식) 순으로 상속 관계가 있을 때,   
ClassC를 생성하면 ClassA의 생성자 호출, 다음으로 ClassB, ClassC 순으로 생성자가 호출됨  
- 초기화는 부모 생성자부터 이루어짐
- 자식 생성자의 첫 줄에서 부모 생성자의 호출해야 됨  

ClassB에는 두개의 생성자가 정의되어 있음  
따라서 ClassC(자식)에서 ClassB(부모)의 생성자를 호출할 때 하나의 생성자만 호출할 수 있음

**상속 관계에서 자식 클래스의 생성자 첫줄에 반드시 `super(...)` 호출해야 함**
**단, 부모 클래스가 기본 생성자인 경우 생략 가능**

**예외**
생성자 첫줄에 this(...) 사용 가능
- 그러나 어쨌든 한번은 반드시 꼭 `super(...)` 호출해야 됨
```java
public class ClassB extends ClassA {

    public ClassB(int a) {
        this(a, 100); //생략 가능
        System.out.println("ClassB 생성자, a = " + a);
    }

    public ClassB(int a, int b) {
        super(); //생략 가능
        System.out.println("ClassB 생성자, a = " + a + ", b = " + b);
    }
}
```
```java
public class Super2Main {
    public static void main(String[] args) {
        ClassB classB = new ClassB(100);
    }
}
```
Main의 ClassB를 생성하면, 매개변수가 하나인 생성자를 호출  
매개변수가 하나인 생성자에서 this(a, 100)을 실행하게 되는데,  
이는 자신 클래스 내부에 있는 다른 생성자(매개변수 2개)를 호출  
결국 매개변수가 2개인 생성자에서 super()을 통해 부모 생성자를 호출하게 됨

## final

**클래스에 `final`**  
- 상속 끝: 더이상 확장될 수 없음
- 즉, final로 선언된 클래스를 상속 받을 수 없음

**메서드에 `final`**  
- 오버라이딩 끝: 더이상 오버라이드될 수 없음
- 즉, 상속 받은 서브클래스에서 해당 메서드를 변경할 수 없음